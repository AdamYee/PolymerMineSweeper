<link rel="import" href="bower_components/polymer/polymer.html">
<link rel="import" href="ms-cell.html">
<script type="text/javascript" src="grid.js"></script>

<polymer-element
  name="ms-board"
  attributes="rows columns mines"
  on-flagged="{{countFlags}}"
  on-explosion="{{createExplosion}}">
  <template>
    <style>
    #board {
      position: relative;
      margin-left: 50px;
      margin-top: 20px;
      display: inline-block;
    }
    #game-end {
      z-index: 100;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center; /* align horizontal */
      align-items: center; /* align vertical */
      font-size: 32px;
      opacity: 0;
      transition: opacity 1.2s;
    }
    #game-end > span {
      background: #fff;
      border-radius: 5px;
      border: 2px solid;
      padding: 0 5px;
      box-shadow: 0 0 4px 0px;
    }
    #game-end.explosions-done {
      opacity: 1;
    }

    </style>
    <div id="board">
      <template repeat="{{ row in grid }}">
        <div horizontal layout>
          <template repeat="{{ cell in row }}">
            <ms-cell
              id="{{cell.id}}"
              cell={{cell}}
              on-reveal-neighbors="{{revealNeighbors}}">
            </ms-cell>
          </template>
        </div>
      </template>
      <div id="game-end" class="{{ {'explosions-done': doneExploding} | tokenList }}" hidden?="{{!gameOver}}">
        <span style="color: {{win ? 'green' : 'red'}}">{{gameEndMessage}}</span>
      </div>
    </div>
  </template>
  <script>
    'use strict';
    Polymer({
      created: function () {
        this.gameOver = false;
        this.win = false;
        this.doneExploding = false;
        this.flagCount = 0;
        this.grid = [];
      },
      /**
       * IMPORTANT: Attributes configured via an element e.g. <x-foo name="bar"></x-foo>
       * are not available in the `created`lifecycle method. They first become available
       * in the `ready` lifecycle method.
       */
      ready: function () {
        this.grid = initialize(this.rows, this.columns, this.mines);
      },
      computed: {
        'gameEndMessage': 'win ? "YOU WIN" : "GAME OVER"'
      },
      countFlags: function (Event, object, element) {
        this.flagCount += object; // object is 1 or -1
      },
      /**
       * Recursively self reveals cells as 0 risk cell are revealed.
       * Recursion is oddly handled through animation. See `propagate` on ms-cell.html.
       */
      revealNeighbors: function (Event, object, element) {
        var position = element.id.split('_').slice(-2); // get grid position from id
        var row = parseInt(position[0]);
        var col = parseInt(position[1]);
        var numRow = this.grid.length; // length of a row
        var numCol = this.grid[0].length; // length of a column
        forEachSurroudingCell(row, col, numRow, numCol)(function (row, col) {
          /**
           * Common Polymer gotcha:
           * Automatic node finding only works 1 level deep in the shadow DOM tree.
           * Anything deeper can be accessed by using `querySelector` on an
           * automatically found node.
           */
          var neighbor = this.$.board.querySelector('#cid_' + row + '_' + col);
          if (!neighbor.cell.flagged) {
            neighbor.revealed = true; // recursion via data-binding
          }
        }.bind(this));
      },
      /**
       * As soon as any mine explodes, this method fires off the rest
       * to make it a board-wide explosion.
       */
      createExplosion: function (Event, object, element) {
        this.gameOver = true;

        var mineCellIds = this.grid.mineArray.map(function(id) { return '#'+id; }).join(',');
        var mines = Array.prototype.slice.call( this.$.board.querySelectorAll(mineCellIds) );
        mines = shuffleArray(mines); // shuffle the mines for a random explosion effect

        // know when to show the game over message - after we're done exploding
        var explodedCount = 0;
        this.addEventListener('webkitAnimationEnd', function (e) {
          if (e.animationName === 'explode') {
            explodedCount++;
            if(explodedCount === mines.length - this.flagCount) { // TODO: refactor when numMines is a property of Grid
              this.doneExploding = true
            }
          }
        }.bind(this));

        mines.forEach(function(cell, i) {
          setTimeout(function () {
            if(!cell.cell.flagged) {
              cell.revealed = true; // explode unflagged mines
            }
          }, i%2===0 ? i*20 : i*15);
        });
      }
    });
    
    /*
    Utils
     */
    
    /**
     * A curry helper method that captures the target cell location
     * in a closure to be used later by the callback(row, column).
     * The curried method will invoke the callback for each surrounding cell
     * that is inside the grid.
     * @param  {number}  row    - 
     * @param  {number}  col    - 
     * @param  {number}  maxRow - 
     * @param  {number}  maxCol - 
     * @return {Boolean}        - 
     */
    function forEachSurroudingCell (row, col, maxRow, maxCol) {
      /**
       * Performs the callback for each cell that is inside the grid
       * @param  {Function} callback - takes optional (row, column) arguments
       */
      return function (callback) {
        var isInsideGrid = false;
        for(var i = -1; i <= 1; i++) {
          for(var j = -1; j <= 1; j++) {
            isInsideGrid = (row + i >= 0 && col + j >= 0 && row + i < maxRow && col + j < maxCol);
            if(isInsideGrid && !(i === 0 && j === 0)) {
              callback(row + i, col + j);
            }
          }
        }
      }
    }
    function shuffleArray(array) {
      for (var i = array.length - 1; i > 0; i--) {
          var j = Math.floor(Math.random() * (i + 1));
          var temp = array[i];
          array[i] = array[j];
          array[j] = temp;
      }
      return array;
    }
  </script>
</polymer-element>
